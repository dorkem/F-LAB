## 👨‍🏫 강의
### 1) SRP, OCP등의 객체지향과 구현 방법들
```
🙋‍♂️ 나:
단일 책임의 원칙으로, 개발을 할 때 한 클래스에 몰리게 되면 책임이 늘어나면서 무거워지니까 나눠서 각자 책임을 갖게 만드는 것입니다.

🧑‍🏫 멘토:
이거 스프링 토비 읽으면서 나온 개념인가요?

🙋‍♂️ 나:
응집도를 보고 따로 공부하다가 나온 개념입니다.

🧑‍🏫 멘토:
객체 지향이라는 것에 대해 공부를 한 것 같습니다. 이게 객체지향의 5원칙(SOLID) 중 1개입니다.
객체지향을 알기 전에 객체라는게 뭘까요? 

🙋‍♂️ 나:
속성과 기능을 묶어둔 것 입니다.

🧑‍🏫 멘토:
너무 이론적인 것 같은데 자바 프로그래밍 할 때 스스로 객체를 뭐라고 생각하시나요

🙋‍♂️ 나:
일상 생활에서 사물 그 자체라고 생각합니다.

🧑‍🏫 멘토:
그럼 객체 지향은 뭘까요?

🙋‍♂️ 나:
사물간의 관계를 갖고 상호작용을 하며 개발하는 것..?

🧑‍🏫 멘토:
이게 좀 더 와닿는 대답인 것 같습니다.
객체 지향의 사실과 오해라는 책을 추천드리는데, 여기서는 객체가 객체로서 시간의 흐름 속에서 상태가 변하며, 다른 객체와 상호작용하는 존재? 라고 얘기합니다.
객체지향은 현실을 그대로 옮기는 게 아니라, 역할과 책임을 기준으로 세계를 다시 나누는 방식입니다.
그래서 객체들은 서로 상호작용하며 협력하고, 시간처럼 추상적인 개념도 객체로 만들어 책임을 맡길 수 있습니다.

객체지향은 객체의 역할·책임·협력을 중심으로 세계를 구성하는 방식이며, 시간 같은 추상적 개념도 객체로 만들어 책임을 맡깁니다.
이런 관점에서 SRP, OCP, ISP, DIP 같은 원칙들은 응집도를 높이고 결합도를 낮춰 협력이 잘 되게 하기 위한 설계 기준이 됩니다.
그럼 왜 SRP가 되야할까요?

🙋‍♂️ 나:
한 사물이 일을 너무 하게되면 비효율적이라고 생각해서 일을 분할해야한다고 생각합니다.

🧑‍🏫 멘토:
왜 프로그램이 커지면 비효율적일까요?

🙋‍♂️ 나:
개발로 쳤을 때 문제가 생기면 해당하는 위치를 찾는데에 어려움이 있을 것 같다.
왜 여기있지?, 여길 고치는게 맞나? 등의 생각이 들 것 같습니다.

🧑‍🏫 멘토:
맞아요 
SRP(단일 책임 원칙)는 클래스가 하나의 역할과 책임만 가져야 필드와 메서드가 자연스럽게 응집되고, 재사용이 쉬워진다는 원칙입니다.
예를 들어 LocalDate처럼 특정 개념(날짜)에 대한 동작만 담당하면, 어디서 쓰더라도 그 책임이 명확해 안전하게 재사용할 수 있습니다.
이 때 응집도에 대한 얘기가 나올 것 같은데 응집도가 높은 프로그램이란 뭘까요?

🙋‍♂️ 나:
자기만의 역할만을 가지고 있는 정도인 것 같습니다.

🧑‍🏫 멘토:
뭔가 키워드가 SRP의 개념에서 벗어나지 않는 것 같습니다.
응집도는 객체 안에 데이터 변수와 메서드 간의 상관관계가 얼마나 밀접한가? 입니다.

예를들면 내부에 name, age, getName(), getAge()가 있는 Member이라는 클래스 1개, name, getName()만 있는 Name 클래스 1개를 비교해보면

Member클래스는 name이라는 변수가 getName()에서 한 번만 쓰이니 0.5, age도 getAge() 한 곳에서만 쓰이니 0.5 => 결국 응집도는 0.5입니다.
Name클래스는 name이라는 변수를 getName에서 100% 사용 중이므로 응집도는 1입니다.

Member은 이름과 나이를 핸들링하는 책임을 2가지를 가지고 있는 것입니다. 그래서 결론적으로 SRP를 지키고 있는 클래스는 Name클래스가 됩니다.
그래서 SRP가 이렇게 코딩해라고 하는겁니다.

그럼 OCP는 뭘까요?

🙋‍♂️ 나:
수정에는 닫혀있고 확장에는 열려있어야한다 입니다.

🧑‍🏫 멘토:
확장에 열려있다가 뭔가요?

🙋‍♂️ 나:
변경시에 수정할 코드의 양이 적은 것 같습니다..

🧑‍🏫 멘토:
그럼 뭐가좋나요?

🙋‍♂️ 나:
팀프로젝트 중에 코드 수정 이후에 커밋하면 충돌나니까 의존도를 많이 줄여야하는 것 같습니다.

🧑‍🏫 멘토:
네 설명해주신게 맞구요
제 생각에 OCP는 일 할 때 보다 프레임워크에 잘 어울리는게, 인터페이스를 다 분리해두고 현업에서 사용하면 코드가 너무 복잡해집니다.
그래서 OCP는 좋은 개념이지만 프레임 워크에서만 적용하는게 좋다는게 제 생각입니다.

@Service 등록하면 스프링에서 관리하고 있으니 스프링 코드를 하나도 안건드려도 자기 혼자 등록됩니다 그게 변경에 닫혀있고, 확장에 열려있어서 그런 것입니다.
만약에 안되어 있었으면 스프링 내부 코드에다가 new잡아서 만들어줬어야 했습니다.
이런 개념들을 토비의 스프링에서 읽을 때 객체지향과 관련이 많고, 스프링 객체 지향 프레임워크다 라는 말을 계속하는데 이런걸 잘 생각하시면서 공부하셔야 합니다.

그럼 IoC DI에 대해서 설명해주세요

🙋‍♂️ 나:
의존성 주입과 그 구현 방법이 DI입니다.

🧑‍🏫 멘토:
두 개는 다른 개념이지만 스프링 프레임 워크에서는 두 개가 너무 밀접하기 때문에 DI는 뭘까요?

🙋‍♂️ 나:
뭔가를 조회할 때 매번 DB커넥션을 하게되면 코드도 너무 복잡해지고, 책임도 무거워 지니까 외부에서 따로 만들어서 갖다쓰게 끔 의존성을 주입해주는 것 입니다.

🧑‍🏫 멘토:
그럼 이게 결합도의 측면에서는 어떤가요?

🙋‍♂️ 나:
높아집니다.

🧑‍🏫 멘토:
왜요? 결합도란 뭔가요?

🙋‍♂️ 나:
의존도가 높아져서 얘 없으면 나는 안된다와 같은 의미입니다.

🧑‍🏫 멘토:
좋아요
팀과 멤버가 있는데 팀 안에 멤버들이 있어야 하잖아요?
멤버들을 어떻게 이 안에 넣을 수 있을지 모르겠지만 멤버 1, 2, 3, 4라는 클래스가 있다고 쳤을 때 팀 안에 new로 4개를 객체로 잡아서 넣어요 그럼 이건 결합도가 매우 높은것입니다.
이렇게 만드는 순간 팀이라는 클래스는 멤버가 없으면 아예 동작을 못한다.
그럼 이걸 인터페이스로 넣어주는 방법을 써야 결합도가 낮아진다. 이러면 멤버 5가 들어와도 동작하게 됩니다.
그럼 다른 방식으로 설명해주세요

🙋‍♂️ 나:
엇

🧑‍🏫 멘토:
로직 안에서 new LocalDate(...)를 직접 쓰면
해당 로직은 LocalDate라는 구체 클래스에 의존하게 됩니다,
즉, 그 클래스 없이는 동작할 수 없으므로 결합도가 높아집니다.

결국 결합도가 높은 코드는 보통 테스트 할 때 어렵고 자바 버전 변경처럼 외부 환경이 바뀔 때
LocalDate가 LocalDate2로 변경된다고 가정했을 때 로직이 함께 깨질 수 있어 외부 변경에 취약해집니다.

🧑‍🏫 멘토:
그럼 DI는 누가넣어주냐

🙋‍♂️ 나:
시간이라고 하면 시간을 관리하는 클래스나, 로컬 데이트를 관리하는 사람을 만들어 생산하여 넣어주는 것 같습니다.

🧑‍🏫 멘토:
넵 그걸 팩토리 패턴이라고 합니다.
팩토리 패턴이 IOC의 가장 원형 모델로 객체를 만들어주는 책임을 가지고 있습니다.

팩토리 패턴으로 어떤 클래스를 만들어서 로직을 만들어놨는데 멘티님이 이걸 쓰려고 할 때 큰 로직들을 신경을 쓰시나요? 아니면 그냥 갖다쓰시나요?

🙋‍♂️ 나:
라이브러리처럼 그냥 갖다씁니다.

🧑‍🏫 멘토:
네 그게 IoC입니다.
제어의 역전이라고, 뭘 역전한거면 내 프로그램의 흐름을 내가 아니라 딴 애에게 넘기는 것입니다.
멘티님의 코드는 멘티님이 컨트롤 하고 있지만, 어떤 객체가 필요해서 가져와야하는데 제 팩토리 패턴을 가져와서 썼다면 저한테 잠깐 책임을 넘긴 것이 되는겁니다.
근데 이게 스프링에서는 스프링 컨테이너가 팩토리 역할을 해주는 것입니다.(@AutoWired처럼) = 빈 컨테이너

이런식으로 연결지어서 공부해주시는 것이 중요합니다.




```
