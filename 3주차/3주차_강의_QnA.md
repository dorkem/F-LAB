## 👨‍🏫 강의
### 1) SRP, OCP등의 객체지향과 구현 방법들
```
🙋‍♂️ 나:
단일 책임의 원칙으로, 개발을 할 때 한 클래스에 몰리게 되면 책임이 늘어나면서 무거워지니까 나눠서 각자 책임을 갖게 만드는 것입니다.


🧑‍🏫 멘토:
이거 스프링 토비 읽으면서 나온 개념인가요?


🙋‍♂️ 나:
응집도를 보고 따로 공부하다가 나온 개념입니다.


🧑‍🏫 멘토:
객체 지향이라는 것에 대해 공부를 한 것 같습니다. 이게 객체지향의 5원칙(SOLID) 중 1개입니다.
객체지향을 알기 전에 객체라는게 뭘까요? 


🙋‍♂️ 나:
속성과 기능을 묶어둔 것 입니다.


🧑‍🏫 멘토:
너무 이론적인 것 같은데 자바 프로그래밍 할 때 스스로 객체를 뭐라고 생각하시나요

🙋‍♂️ 나:
일상 생활에서 사물 그 자체라고 생각합니다.


🧑‍🏫 멘토:
그럼 객체 지향은 뭘까요?


🙋‍♂️ 나:
사물간의 관계를 갖고 상호작용을 하며 개발하는 것..?


🧑‍🏫 멘토:
이게 좀 더 와닿는 대답인 것 같습니다.
객체 지향의 사실과 오해라는 책을 추천드리는데, 여기서는 객체가 객체로서 시간의 흐름 속에서 상태가 변하며, 다른 객체와 상호작용하는 존재? 라고 얘기합니다.
객체지향은 현실을 그대로 옮기는 게 아니라, 역할과 책임을 기준으로 세계를 다시 나누는 방식입니다.
그래서 객체들은 서로 상호작용하며 협력하고, 시간처럼 추상적인 개념도 객체로 만들어 책임을 맡길 수 있습니다.

객체지향은 객체의 역할·책임·협력을 중심으로 세계를 구성하는 방식이며, 시간 같은 추상적 개념도 객체로 만들어 책임을 맡깁니다.
이런 관점에서 SRP, OCP, ISP, DIP 같은 원칙들은 응집도를 높이고 결합도를 낮춰 협력이 잘 되게 하기 위한 설계 기준이 됩니다.
그럼 왜 SRP가 되야할까요?


🙋‍♂️ 나:
한 사물이 일을 너무 하게되면 비효율적이라고 생각해서 일을 분할해야한다고 생각합니다.


🧑‍🏫 멘토:
왜 프로그램이 커지면 비효율적일까요?


🙋‍♂️ 나:
개발로 쳤을 때 문제가 생기면 해당하는 위치를 찾는데에 어려움이 있을 것 같다.
왜 여기있지?, 여길 고치는게 맞나? 등의 생각이 들 것 같습니다.


🧑‍🏫 멘토:
맞아요 
SRP(단일 책임 원칙)는 클래스가 하나의 역할과 책임만 가져야 필드와 메서드가 자연스럽게 응집되고, 재사용이 쉬워진다는 원칙입니다.
예를 들어 LocalDate처럼 특정 개념(날짜)에 대한 동작만 담당하면, 어디서 쓰더라도 그 책임이 명확해 안전하게 재사용할 수 있습니다.
이 때 응집도에 대한 얘기가 나올 것 같은데 응집도가 높은 프로그램이란 뭘까요?


🙋‍♂️ 나:
자기만의 역할만을 가지고 있는 정도인 것 같습니다.


🧑‍🏫 멘토:
뭔가 키워드가 SRP의 개념에서 벗어나지 않는 것 같습니다.
응집도는 객체 안에 데이터 변수와 메서드 간의 상관관계가 얼마나 밀접한가? 입니다.

예를들면 내부에 name, age, getName(), getAge()가 있는 Member이라는 클래스 1개, name, getName()만 있는 Name 클래스 1개를 비교해보면

Member클래스는 name이라는 변수가 getName()에서 한 번만 쓰이니 0.5, age도 getAge() 한 곳에서만 쓰이니 0.5 => 결국 응집도는 0.5입니다.
Name클래스는 name이라는 변수를 getName에서 100% 사용 중이므로 응집도는 1입니다.

Member은 이름과 나이를 핸들링하는 책임을 2가지를 가지고 있는 것입니다. 그래서 결론적으로 SRP를 지키고 있는 클래스는 Name클래스가 됩니다.
그래서 SRP가 이렇게 코딩해라고 하는겁니다.

그럼 OCP는 뭘까요?


🙋‍♂️ 나:
수정에는 닫혀있고 확장에는 열려있어야한다 입니다.


🧑‍🏫 멘토:
확장에 열려있다가 뭔가요?


🙋‍♂️ 나:
변경시에 수정할 코드의 양이 적은 것 같습니다..


🧑‍🏫 멘토:
그럼 뭐가좋나요?


🙋‍♂️ 나:
팀프로젝트 중에 코드 수정 이후에 커밋하면 충돌나니까 의존도를 많이 줄여야하는 것 같습니다.


🧑‍🏫 멘토:
네 설명해주신게 맞구요
제 생각에 OCP는 일 할 때 보다 프레임워크에 잘 어울리는게, 인터페이스를 다 분리해두고 현업에서 사용하면 코드가 너무 복잡해집니다.
그래서 OCP는 좋은 개념이지만 프레임 워크에서만 적용하는게 좋다는게 제 생각입니다.

@Service 등록하면 스프링에서 관리하고 있으니 스프링 코드를 하나도 안건드려도 자기 혼자 등록됩니다 그게 변경에 닫혀있고, 확장에 열려있어서 그런 것입니다.
만약에 안되어 있었으면 스프링 내부 코드에다가 new잡아서 만들어줬어야 했습니다.
이런 개념들을 토비의 스프링에서 읽을 때 객체지향과 관련이 많고, 스프링 객체 지향 프레임워크다 라는 말을 계속하는데 이런걸 잘 생각하시면서 공부하셔야 합니다.

그럼 IoC DI에 대해서 설명해주세요


🙋‍♂️ 나:
의존성 주입과 그 구현 방법이 DI입니다.


🧑‍🏫 멘토:
두 개는 다른 개념이지만 스프링 프레임 워크에서는 두 개가 너무 밀접하기 때문에 DI는 뭘까요?


🙋‍♂️ 나:
뭔가를 조회할 때 매번 DB커넥션을 하게되면 코드도 너무 복잡해지고, 책임도 무거워 지니까 외부에서 따로 만들어서 갖다쓰게 끔 의존성을 주입해주는 것 입니다.


🧑‍🏫 멘토:
그럼 이게 결합도의 측면에서는 어떤가요?


🙋‍♂️ 나:
높아집니다.


🧑‍🏫 멘토:
왜요? 결합도란 뭔가요?


🙋‍♂️ 나:
의존도가 높아져서 얘 없으면 나는 안된다와 같은 의미입니다.


🧑‍🏫 멘토:
좋아요
팀과 멤버가 있는데 팀 안에 멤버들이 있어야 하잖아요?
멤버들을 어떻게 이 안에 넣을 수 있을지 모르겠지만 멤버 1, 2, 3, 4라는 클래스가 있다고 쳤을 때 팀 안에 new로 4개를 객체로 잡아서 넣어요 그럼 이건 결합도가 매우 높은것입니다.
이렇게 만드는 순간 팀이라는 클래스는 멤버가 없으면 아예 동작을 못한다.
그럼 이걸 인터페이스로 넣어주는 방법을 써야 결합도가 낮아진다. 이러면 멤버 5가 들어와도 동작하게 됩니다.
그럼 다른 방식으로 설명해주세요


🙋‍♂️ 나:
엇


🧑‍🏫 멘토:
로직 안에서 new LocalDate(...)를 직접 쓰면
해당 로직은 LocalDate라는 구체 클래스에 의존하게 됩니다,
즉, 그 클래스 없이는 동작할 수 없으므로 결합도가 높아집니다.

결국 결합도가 높은 코드는 보통 테스트 할 때 어렵고 자바 버전 변경처럼 외부 환경이 바뀔 때
LocalDate가 LocalDate2로 변경된다고 가정했을 때 로직이 함께 깨질 수 있어 외부 변경에 취약해집니다.


🧑‍🏫 멘토:
그럼 DI는 누가넣어주냐


🙋‍♂️ 나:
시간이라고 하면 시간을 관리하는 클래스나, 로컬 데이트를 관리하는 사람을 만들어 생산하여 넣어주는 것 같습니다.


🧑‍🏫 멘토:
넵 그걸 팩토리 패턴이라고 합니다.
팩토리 패턴이 IOC의 가장 원형 모델로 객체를 만들어주는 책임을 가지고 있습니다.

팩토리 패턴으로 어떤 클래스를 만들어서 로직을 만들어놨는데 멘티님이 이걸 쓰려고 할 때 큰 로직들을 신경을 쓰시나요? 아니면 그냥 갖다쓰시나요?


🙋‍♂️ 나:
라이브러리처럼 그냥 갖다씁니다.


🧑‍🏫 멘토:
네 그게 IoC입니다.
제어의 역전이라고, 뭘 역전한거면 내 프로그램의 흐름을 내가 아니라 딴 애에게 넘기는 것입니다.
멘티님의 코드는 멘티님이 컨트롤 하고 있지만, 어떤 객체가 필요해서 가져와야하는데 제 팩토리 패턴을 가져와서 썼다면 저한테 잠깐 책임을 넘긴 것이 되는겁니다.
근데 이게 스프링에서는 스프링 컨테이너가 팩토리 역할을 해주는 것입니다.(@AutoWired처럼) = 빈 컨테이너

이런식으로 연결지어서 공부해주시는 것이 중요합니다.
```


### 2) Dispatcher Servlet
```
🙋‍♂️ 나:
요청 → DispatcherServlet → 핸들러(컨트롤러) 찾기 → 핸들러 어댑터가 실행 → 결과 반환 → 뷰 선택 → 응답


🧑‍🏫 멘토:
웬만하면 코드를 보면서 이해하는게 좋은 것 같습니다.
```


### 3) Dispatcher Servlet
```
🙋‍♂️ 나:
메서드별로 로그나 시간측정 등을 할 때 매번 코드를 추가하면 복잡해져서 메서드 실행 전후에 실행하도록 해주는 것 입니다.


🧑‍🏫 멘토:
만약에 500개 메서드에다가 실행시키려면 어떻게 해야할까요?


🙋‍♂️ 나:
앞뒤에 다 쓰거나 클래스에 공통 메서드로 분리할 것 같습니다.


🧑‍🏫 멘토:
클래스가 500개면요?
AOP는 껴넣기 프로그래밍이라고 로깅과 시간측정 같은 “공통 기능”을 따로 빼서 필요한 곳에 자동으로 끼워 넣는 방식입니다.
또한 데코레이터 패턴이라고 하는데 데코레이트 패턴은 원래 기능은 유지하면서, 앞뒤로 기능을 덧붙이는 패턴입니다.

스프링에서는 이걸 누가 만들어주냐? @Service 같은 빈을 등록하면 AOP 설정(@Aspect 등)을 보고 “이 빈은 AOP 대상이네?”
그럼 원본 빈 대신 프록시 빈을 컨테이너에 등록해서 우리가 주입받는 건 사실 원본이 아니라 프록시입니다.

여튼 진짜 객체(멤버서비스) 앞에 대신 받아주는 대리인 객체를 하나 세워서 실제로 “프록시”를 호출하면 프록시가 중간에서 로깅 같은 부가기능을 하고 그다음 진짜 멤버서비스에게 일을 시킵니다.
JDK 동적 프록시는 특징이 하나 있는데 인터페이스 기반으로만 프록시를 만들 수 있습니다.
MemberService(인터페이스) 가 있어야 하고 MemberServiceImpl(구현체) 가 있고 프록시는 MemberService를 구현한 대리 객체로 만들어집니다.


🙋‍♂️ 나:
인터페이스 없으면 안되나요?


🧑‍🏫 멘토:
CGLIB 프록시는 인터페이스를 구현하는 방식이 아니라, 클래스를 상속해 바이트코드 레벨에서 프록시 클래스를 생성합니다.
이로 인해 인터페이스 없이도 클래스 자체를 프록시로 감쌀 수 있습니다.

CGLIB 기반 AOP는 이렇게 생성된 프록시에서 메서드를 오버라이드해 실행 전·후에 로깅이나 트랜잭션 같은 부가기능을 삽입합니다.
따라서 final이나 private 메서드는 오버라이드가 불가능해 가로챌 수 없고, 자기 자신 내부 호출(self-invocation)은 프록시를 거치지 않기 때문에
트랜잭션이나 AOP가 적용되지 않습니다.

즉, AOP는 프록시를 통해 외부에서 호출될 때만 동작하며, 이 특성을 이해해야 트랜잭션이 적용되지 않는 이유를 설명할 수 있습니다.
```


## 🗨 SLACK 질문
### 1) DB 및 네트워크
```
🙋‍♂️ 나:
우선 DB 커넥션을 하고있는데 자바에서 디비커넥션을 하면 내부에서 무슨 일이 일어나나요?


🧑‍🏫 멘토:
자바에서 디비커넥션을 하면 내부에서 무슨 일이 일어나냐는 질문이 너무 포괄적이어서요~ 조금만 정확히 말씀주실 수 있으실까요~?


🙋‍♂️ 나:
통신은 TCP로 할 것 같은데 그럼 이게 HTTP랑 다른게 뭔지, 한다면 JVM과 하는건지, 데이터 삽입까지의 대략적인 과정 등이 좀 궁금합니다. 

🧑‍🏫 멘토:
아하 그렇군요!
먼저, HTTP와 TCP를 완전히 구분하여 생각하시는게 중요할 것 같아요. 아래의 기반 지식이 필요한데요.
 - osi 7 layer에서 http는 7계층이고, tcp는 4계층 입니다. 즉, tcp위에 http가 만들어진 형태입니다.
 - HTTP는 프로토콜  즉, 어플리케이션 레벨의 메시지 규약입니다. 프로토콜에 대한 이해가 필요합니다.

db connection이라 하면 일반적으로 jdbc를 이용하게 될 것 같은데요. jdbc는 내부적으로 벤더사에 따라 적절할 프로토콜을 이용해 db와 통신을 진행하게 됩니다.
대략적으로 아래와 같은 일이 벌어질거에요.
 - jdbc를 통해 연결을 시도함
 - java 는 소켓을 생성함.
 - 소켓은 db와 tcp 연결을 수행 (3 way handshake)
 - db와 java 어플리케이션은 서로 약속한 프로토콜로 데이터를 주고받음.
 - 소켓은 db로 패킷을 받음.
 - JDBC 드라이버가 DB 프로토콜 단위로 메시지를 파싱
 - 데이터를 객체에 맵핑.
 - 어플리케이션에서 사용


🙋‍♂️ 나:
http가 tcp위에서 동작한다는 사실을 조금 잊고있었네요. 검색해보니 tcp는 reliable한 "전달"을 목표로하고, http는 요청의 의미 등을 파악하기 위해 사용합니다.
db연결과 웹 연결의 결정적인 차이는 'stateless해야하냐, 아니냐' 인것 같아요


🧑‍🏫 멘토:
좋은 생각이신 것 같아요! HTTP의 가장 큰 특징 중 하나가, stateless하나는 특징이 있지요.
stateless하다는 특징인 비단 db connection과 http connection 의 차이일까요 아니면 다른 케이스도 있을까요?
웹 연결이라는 용어보다는 명확하게 http 연결이라고 말씀주시는게 좋아요. http가 hyper text를 위해 나온 protocol은 맞지만, 단순 웹 호출에서만 쓰이지는 않으니까요 ㅎㅎ


🙋‍♂️ 나:
"JDBC드라이버가 DB프로토콜 단위로 메시지를 매핑한다"
 예를들어 "select * from FLAB"이라고 작성했을 때 JDBC는 JVM위에서 동작하므로 바이트코드를 연결된 DB에 맞는 기계어로 변환한다는 뜻인가요?


🧑‍🏫 멘토:
일단, jdbc는 규약이지 구현이 아니기 때문에 jvm 위에서 동작한다는 말은 명확하지는 않습니다! 일반적으로 많이 사용하는 mysql기반으로 말씀 드리면 `mysql 드라이버가 해당 작업을 한다 ` 라고 말씀드릴 수 있을 것 같아요!
 - 바이트 코드를 연결된 db에 맞는 기계어로 변환하다는 의미는 아니구요, 정확히는 패킷을 모아서 byte stream으로 만들고 이것을 데이터화 시킨다는 의미인데. 제가 지금 생각하기에는 네트워크의 동작 방식에 대해서 조금 더 공부를 하고서 요 부분을 고민해보시면 좋을 것 같습니다!
 - 성공과 실패를 결정하는 1 의 네트워크 원리 라는 책이 있는데요. 여기에서 재혁님이 궁금해하시는 부분을 많이 해소시켜줄 수 있을 것 같아요!


🙋‍♂️ 나:
클라이언트의 요청 -> WebServer -> WAS -> DB의 요청에서 요청이 들어오면 Tomcat이 Servlet을 호출하여 메시지를 파싱하고, 해당 요청에 대한 응답을 만들어 전송하는것이라고 알고있는데
GPT에 물어보니 요청이 들어오면 먼저 톰켓 커넥터(Coyote)라는 친구 파싱한다고 하는데 두 개가 다른 파싱을 하는건가요?


🧑‍🏫 멘토:
제가 알고있는 지식으로는, 톰켓커넥터는 조금 더 네트워크딴의 데이터를 파싱하고, servlet에서는 어플리케이션딴의 데이터를 파싱하는걸로 알고 있습니다. 톰켓커넥터는 패킷으로 들어온 데이터를 http 규약에 따라서 파싱하여 HttpServletRequest를 만들구요., servlet에서는 HttpServletRequest를 이용해서 헤더라던지, body를 뽑아낼 수 있어요.
둘 다 파싱하는게 같지만 영역이 조금 다르다고 생각해주시면 되어요~


질문주신 내용들이 network + servlet에 대한 내용이 많은 것 같습니다!
스프링 구조를 공부하시다 보니 의문점들이 생기신 것 같은데요, 상위딴에서 이해가 잘 안되는 부분이 있다면,
(예를들어, JDBC드라이버가 DB프로토콜 단위로 메시지를 매핑한다 라는 문장처럼요) 키위드 기반으로 한번 알아보시는것 좋은 것 같아요!
다만, 그 키워드 기반으로 공부를 하실 때 방향성과 깊이에 대해 고민해보시면 좋을 것 같은데요. 예를들어 JVM위에서 db와의 통신 을 고민하시다 보니
약간은 JVM 이라는 것에 생각이 많아지신 것 같아요 (bytecode이야기가 계속 나오길레요). 문제를 단순화 시키면 위 질문은 network입니다.
질문을 db와 서버와의 통신은 network 레이어에서 어떻게 일어나지? 로 조금 구체화 시키면 원하시는 답변을 얻으실 수 있을 것 같습니다 : )
```
