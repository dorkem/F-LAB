## 👨‍🏫 강의
### 1) ArrayList와 LinkedList의 차이점
```
🙋‍♂️ 나: ArrayList는 불변이고, LinkedList는 가변이다.

🧑‍🏫 멘토: 배열을 100개로 잡고 값을 101개 넣으면 어떻게 되나요?
🙋‍♂️ 나: 오버플로우가 발생한다.

🧑‍🏫 멘토: 그렇지 않다. 리스트 자료구조에 대해 알고 있는가? 배열과 리스트의 차이를 말해보라.
🙋‍♂️ 나: 잘 모르겠다.

🧑‍🏫 멘토: 배열은 메모리에 순차적으로 할당되며, 고정된 크기 내에서 데이터를 추가하고 제거해야 한다.
리스트는 자바의 컬렉션 인터페이스 중 하나로, 가변적으로 데이터를 추가하고 제거할 수 있다.
그렇다면 아까 LinkedList를 가변이라고 한 이유가 있을까?
🙋‍♂️ 나: LinkedList는 노드가 연속된 메모리 공간에 있지 않아도 연결만 시켜주기 때문이다.

🧑‍🏫 멘토: 맞다.
```
   
### 2) JVM 설명이 되는가
```
🙋‍♂️ 나: 자바가 실행되는 환경이지만, 정확하게는 잘 기억나지 않는다.

🧑‍🏫 멘토: JVM은 Java Virtual Machine의 약자이다.
과거에는 운영체제(OS)가 다르면 각 환경에 맞게 프로그램을 따로 개발해야 했다.
자바는 이 문제를 해결하기 위해 가상 머신이라는 중간 레이어를 두었고,
자바 프로그램은 이 JVM 위에서 실행되도록 설계되었다.
```

### 3) 힙과 스택의 차이를 아는가?
```
🙋‍♂️ 나: 메서드가 호출되면 스택에 쌓이고, 그 과정에서 생성되는 객체는 힙에 저장된다.
🧑‍🏫 멘토: JVM의 메모리 구조에 대해 알고 있는지를 확인하기 위해 질문한 것이다.
```

### 4) 쓰레드와 프로세스의 차이를 아는가?
```
🙋‍♂️ 나: 쓰레드는 쓰레드 풀에서 생성되어 여러 작업을 병렬로 처리할 수 있게 해주는 개념이고,
프로세스는 프로그램을 실행할 때 사용하는 단위인 것 같다.

🧑‍🏫 멘토: 쓰레드 풀이라는 개념은 어디에서 들어봤는가?
🙋‍♂️ 나: 서블릿 프로젝트를 할 때 들어봤다.

🧑‍🏫 멘토: 그때 등장한 개념은 운영체제(OS)의 개념일까, 아니면 스프링의 개념일까?
🙋‍♂️ 나: 아마 스프링인 것 같다.

🧑‍🏫 멘토: 그렇다면 임계 영역(Critical Section)이라는 개념은 알고 있는가?
🙋‍♂️ 나: 락(Lock) 개념으로 얼핏 기억난다.

🧑‍🏫 멘토: 프로세스와 쓰레드를 이야기할 때는 메모리를 서로 공유하는지 여부가 중요한 개념이기 때문에 질문한 것이다.
```

### 5) TCP와 UDP의 차이를 아는가?
```
🙋‍♂️ 나: TCP는 3-way handshake을 하고, UDP는 패킷 손실을 감안하고 보내는 것에만 집중한다.

🧑‍🏫 멘토: 그렇다면 각각 어디에 사용되는가?
🙋‍♂️ 나: 잘 모르겠다.

🧑‍🏫 멘토: 과거에는 UDP가 대표적으로 사용되던 영역이 스트리밍이었다.
프레임 하나가 1초 정도 늦게 나가거나 일부 손실되는 것이 크게 중요하지 않았기 때문이다.
다만 요즘은 프로토콜이 발전하면서 스트리밍에서도 TCP를 사용하는 경우가 많아졌다.
반면 게임에서 스킬을 눌렀는데 동작이 발생하지 않는 상황처럼,
반드시 전달되어야 하는 경우에는 TCP를 사용한다.
```

### 6) 인덱스 왜 사용함?
```
🙋‍♂️ 나: 값을 빠르게 찾아가기 위해 사용한다.

🧑‍🏫 멘토: 인덱스가 없으면 데이터를 찾을 수 없는가?
🙋‍♂️ 나: 삭제나 삽입이 발생했을 때 탐색이 조금 어려워질 것 같다.

🧑‍🏫 멘토: B-Tree 기반 인덱스와 100만 건의 데이터가 순차적으로 있을 때를 비교하여,
Big-O 표기법으로 탐색 복잡도를 설명해보라.

🧑‍🏫 멘토:
인덱스는 B-Tree 구조를 사용하여 탐색 시 시간 복잡도를 O(log n)으로 줄여주며,
인덱스가 없을 경우에는 O(n)으로 모든 데이터를 순차 탐색해야 하므로 성능 차이가 크다.
```

### 7) 커밋과 롤백에 차이
```
🧑‍🏫 멘토: 커밋은 트랜잭션에서 수행한 변경 사항을 데이터베이스에 영구적으로 반영하는 것이고,
롤백은 트랜잭션 수행 중 발생한 변경 사항을 모두 이전 상태로 되돌리는 것이다.
```

### 8) 트랜잭션이 뭔지
```
🧑‍🏫 멘토: 트랜잭션은 데이터베이스 작업을 하나의 논리적인 단위로 묶은 것이며,
모두 성공하거나 모두 실패해야 하는 작업의 최소 단위이다.
ACID도 기억해야한다.
```

### 9) 미션
```
🧑‍🏫 멘토: 자바의신 왜 안읽었냐 읽어와라
```


<br>
<br>

## 🗨 SLACK 질문
### 1) DTO에 SETTER?
```
🙋‍♂️ 나: DTO는 단지 데이터를 운반하는 역할이라 옛날부터 setter을 쓰나마나로 많이 고민했었는데 멘토님의 의견이 궁금합니다.

🧑‍🏫 멘토: 
말씀주신대로 DTO는 Data Transfer Object로 데이터 운반을 위해 사용됩니다.
DTO라는 개념은 마틴파울러의 Patterns of Enterprise Application Architecture 에서 처음 소개되었는데요. (물론 비슷한 개념으로 VO 라는 개념이 존재하긴 했습니다. 이는 현 개발생태계에서 말하는 Value Object와는 또 다른 개념입니다.)
결론적으로, DTO는 java라는 언어에 종속된것도 아닌, 데이터를 운반하는 방식을 정의하는 단순 개념입니다. 개인적으로는 json으로 주고받는 데이터 또한 DTO의 일종이라고 생각하고 있어요.
따라서 setter를 사용하냐마냐는 DTO의 개념이 아니라 불변객체의 개념으로 접근하시는게 좋다고 생각합니다. -> 즉, dto이기 때문에 setter를 사용 해도 되냐 안되냐는 큰 논의사항이 아니라고 생각합니다.
불변객체를 왜 사용해야하는지에 대해서 공부하시다 보면 아시겠지만, 멀티스레드 환경에서의 문제라던지, 객체의 값이 변하면서 생기는 개념상의 문제들을 많이 해소해주지요. 유지보수의 관점에서 객체의 값이 예측되어 버그 가능성도 작아지구요.
```

### 2) DTO에 Serializable 사용에 대해서
```
🙋‍♂️ 나: public class CastingDTO implements Serializable을 보고 왜 시리얼라이즈를 구현했는지 궁금합니다.

🧑‍🏫 멘토: 
자바의신 직렬화 역직렬화 부분을 봐주시면 좋을 것 같습니다
실제로 자바직렬화를 사용할떄 Serializable이 없으면 에러가 발생합니다

🙋‍♂️ 나:
Serializable 인터페이스에는 변수나 메소드가 존재하지 않지만 Serializable 인터페이스를 구현하면
컴파일러와 JVM은 객체가 직렬화, 역직렬화가 가능한 객체라는 것을 "마크"? 해놓고 나중에 직렬화를 수행할 때 참고합니다.
InputStream과 OutputStream을 ObjectInputStream, ObjectOutputStream이 확장해서 각각 역직렬화, 직렬화가 수행됩니다.
```

### 3) ArrayList의 상속구조
```
🙋‍♂️ 나:
ArrayList는 오브젝트 → AbstractCollection → AbstractList → ArrayList 순으로 상속하고있고, 
Collection, Iterable 인터페이스를 구현 했다고 책에 적혀있습니다.

이 문장과 Iterable을 확장한 Collection을 구현한 AbstractCollection을 상속했다고 GPT가 알려줬는데 이 문장이 같은 의미인건가요?

🧑‍🏫 멘토: 
거의 비슷한 내용이라 볼 수 있을 것 같아요.
AbstractionCollection의 구현을 보시면 iterable과 Collection의 구현(인터페이스이므로) 임을 볼 수 있습니다.
```

### 4) LinkedList vs ArrayList
```
🙋‍♂️ 나:
LinkedList는 값의 삽입, 삭제가 많은 경우에 ArrayList보다 유리하다고 하는데,
노드들이 메모리의 서로 다른 위치에 존재하다 보니 연속 메모리를 사용하는 ArrayList보다 GC 비용이 더 클 것 같습니다.
그러면 ArrayList와 LinkedList 중 어떤 비용 요소를 기준으로 컬렉션을 선택하는 것이 좋을까요?

🧑‍🏫 멘토: 
정답을 알려드리기 보다는 힌트만 드려보겠습니다!
데이터가 매우 많은 리스트의 중간에 있는 요소 하나를 삭제했을 때, 두 구현은 어떻게 동작할까요?

🙋‍♂️ 나:
ArrayList는 빈 공간을 메우기 위해 앞으로 쭉 당기는 비용이 좀 크고,
GC할 때 한 곳을 참조하니까 찾는 비용과, 값 하나만 지우면 되니 삭제 부담이 적을 것 같습니다.
LinkedList는 삭제후 앞뒤 연결만하면 되니 이 해당 비용을 제외하고는 노드 하나하나를 메모리에서 쭉 타고가야해서 번거롭고,
next, prev등을 모두 지워야해서 삭제부담이 더 많을 것 같은데 의도하신 답변이 맞을까요..?

🧑‍🏫 멘토:
Gc가 어떻게 동작하는지 혹시 이해하고 계실까요~?
버전마다 다르긴 하지만 arraylist가 말씀하시는대로 gc가 발생하지는 않을 것 같습니다.
Arraylist에서 빈 공간을 매웠는데  gc할 공간이 어디서 생기게 되는걸까요??
Gc의 개념으로 접근하시기 보다는 자료구조의 개념부터 차근차근 접근해보시는게 좋을 것 같아요.
저번에 빅O 표기법에 대해 말씀드렸는데요, 삽입 삭제 연산에 대해 각각 빅O 몇으로 계산되는지 알아보시는건 어떨까요!?

🙋‍♂️ 나:
ArrayList<String> name = new ArrayList<>();이렇게 객체를 잡게되면
Stack영역에 name(heap에 잡힌 객체의 주소값을 참조), heap 영역에 객체(오브젝트 배열)이 잡히게 됩니다.
또한 중간에 있는 친구를 삭제하게 된다면 ArrayList인 경우에는
System.arraycopy() 를 사용하여 엑셀의 ctrl + x기능처럼 앞으로 당기게 되면 맨 뒷자리에 공간이 비고, 참조가 끊기면서 null이되니 GC의 대상이 되는 것 같습니다.
그럼 하나씩 n개의 배열을 앞으로 당기는 작업이 있기 때문에 O(n) 복잡도가 생기게 됩니다.
링크드리스트도 중간노드까지 접근하는데 N번의 연산이 발생하므로 O(n)의복잡도가 생기는 것 같습니다.

🧑‍🏫 멘토:
GC는 하나하나 없애지 않고 한 번에 뭉쳐서 최적의 시간이 됐을 때 없애기 때문에 그걸로 LinkedList와 ArrayList의 성능 차이를 비교하는 것은 무의미합니다.
GC를 신경써야하는 케이스가 하나 있긴한데 힙에다가 뭔가 어떤 공간을 할당하는 것에 대해서 얘기 해보면
a라는 스트링이 있는데 aaaa 이런식으로 계속 붙이고싶다, 이런식으로 100만개 이어붙이려고 하면 속도가 잘 나올까요?

🙋‍♂️ 나: 별로 오래 안걸릴 것 같습니다.

🧑‍🏫 멘토:
버전마다 다르지만 낮은 버전 기준으로 a라는 객체를 힙에다 할당하고, +a를 붙이면 원래 있던걸 버리고 aa라는걸 재할당을 함,
이런식으로 객체가 100만번 생기기 때문에 GC가 발생해서 프로그램이 느려진다. 이럴땐 고려해야합니다.
예를들면 현업에서는 대용량 트래픽을 받을 때 트래픽마다 객체를 발생시킬지, 캐싱을 해서 쓸지에 따라 성능고려를 신경씁니다.

🧑‍🏫 멘토:
ArrayList와 LinkedList 둘 다 O(n)의 복잡도가 생긴다고 말씀하셨는데 삽입이나 삭제에 극명한 차이가 케이스가 있거든요 뭘까요?

🙋‍♂️ 나:
LinkedList에서 바로 앞 삽입은 O(1)이고, ArrayList는 O(1)입니다.

🧑‍🏫 멘토:
가장 큰 차이는 이것이고, Queue의 구현체가 LinkedList인데 왜 일까요?

🙋‍♂️ 나:
FIFO?

🧑‍🏫 멘토:
맨 앞에 있는걸 뺄 때 더 효율적이기 때문입니다. 그럼 Deque라는 자료구조를 아시나요? Queue는 한쪽에서 넣고 한쪽으로 뺄 수 있지만, Deque는 양쪽으로 빼는게 용이합니다.
그래서 Deque은 ArrayDeque은 ArrayList로 구현되어있는데 그 이유가 뭘까요? 
```
